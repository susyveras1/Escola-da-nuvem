‚úÖ Boas pr√°ticas de c√≥digo limpo aplicadas neste exemplo:

1. üß† Nomes descritivos e significativos:
   - Classes, fun√ß√µes e vari√°veis com nomes claros (ex: `NotificationService`, `user`, `send`).

2. üîÑ Fun√ß√µes pequenas e focadas:
   - Cada fun√ß√£o/m√©todo realiza apenas uma tarefa bem definida.

3. üì¶ Organiza√ß√£o l√≥gica:
   - Separa√ß√£o de responsabilidades por classe (ex: envio, dados do usu√°rio, orquestra√ß√£o).

4. üîÅ Evitar duplica√ß√£o:
   - Uso de heran√ßa e abstra√ß√£o para reaproveitar comportamento.

5. üß± Baixo acoplamento e alta coes√£o:
   - Classes independentes e f√°ceis de testar, alterar ou estender.

6. üß™ C√≥digo previs√≠vel:
   - Segue padr√µes comuns, facilitando leitura e manuten√ß√£o por outros desenvolvedores.

7. üìÉ Coment√°rios apenas quando necess√°rio:
   - O c√≥digo "fala por si"; coment√°rios explicam apenas o essencial (como princ√≠pios aplicados).

------------------------------------------------------------------------------------------------------------------------

üß± Princ√≠pios SOLID aplicados:
S - Single Responsibility: cada classe tem uma √∫nica responsabilidade (ex: User, EmailSender, NotificationService).
O - Open/Closed: √© poss√≠vel adicionar novos tipos de envio sem modificar o c√≥digo existente.
L - Liskov Substitution: classes filhas (EmailSender, SMSSender) substituem a classe base sem quebrar o sistema.
I - Interface Segregation: usamos apenas os m√©todos necess√°rios em interfaces (sem sobrecarga).
D - Dependency Inversion: o servi√ßo depende de uma abstra√ß√£o (NotificationSender), n√£o de implementa√ß√µes concretas.

Esse c√≥digo serve como base para projetos mais complexos, incentivando uma arquitetura limpa, test√°vel e sustent√°vel.


from abc import ABC, abstractmethod

# Princ√≠pio S ‚Äî Single Responsibility (Responsabilidade √önica)
class User:
    def __init__(self, name: str, email: str, phone: str):
        self.name = name
        self.email = email
        self.phone = phone

# Princ√≠pio O ‚Äî Open/Closed (Aberto para extens√£o, fechado para modifica√ß√£o)
class NotificationSender(ABC):
    @abstractmethod
    def send(self, user: User, message: str) -> None:
        pass

# Princ√≠pio L ‚Äî Liskov Substitution (Substitui√ß√£o de Liskov)
class EmailSender(NotificationSender):
    def send(self, user: User, message: str) -> None:
        print(f"üìß Enviando e-mail para {user.email}: {message}")

class SMSSender(NotificationSender):
    def send(self, user: User, message: str) -> None:
        print(f"üì± Enviando SMS para {user.phone}: {message}")

# Princ√≠pio I ‚Äî Interface Segregation (Segrega√ß√£o de Interface)
# N√£o for√ßamos a classe a implementar m√©todos desnecess√°rios ‚Äî a interface NotificationSender √© simples e focada.

# Princ√≠pio D ‚Äî Dependency Inversion (Invers√£o de Depend√™ncia)
class NotificationService:
    def __init__(self, sender: NotificationSender):
        self.sender = sender

    def notify(self, user: User, message: str) -> None:
        self.sender.send(user, message)

# Uso
if __name__ == "__main__":
    user = User("User", "seuemail@email.com", "+xx xx xxxx-xxxx")
    
    email_service = NotificationService(EmailSender())
    email_service.notify(user, "Seu curso de AWS come√ßa hoje √†s 19h!")
    
    sms_service = NotificationService(SMSSender())
    sms_service.notify(user, "N√£o se esque√ßa de revisar Python por 30 minutos hoje!")
